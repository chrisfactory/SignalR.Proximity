using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Immutable;

namespace SignalR.Proximity.TS.ContractGenerator
{
    [Generator]
    public class TypeScriptContractGenerator : IIncrementalGenerator
    {
        private const string AttributeName = "SignalR.Proximity.ProximityTypeScriptCodeSyncAttribute";

        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            // 0. Inject Attribute
            context.RegisterPostInitializationOutput(ctx => ctx.AddSource("ProximityTypeScriptCodeSyncAttribute.g.cs", @"
using System;

namespace SignalR.Proximity
{
    [AttributeUsage(AttributeTargets.Interface, Inherited = false, AllowMultiple = false)]
    public sealed class ProximityTypeScriptCodeSyncAttribute : Attribute
    {
        public string TargetPath { get; }

        public ProximityTypeScriptCodeSyncAttribute(string targetPath)
        {
            TargetPath = targetPath;
        }
    }
}"));

            // 1. Find interfaces with the attribute
            var pipelines = context.SyntaxProvider.ForAttributeWithMetadataName(
                AttributeName,
                predicate: (node, _) => node is InterfaceDeclarationSyntax,
                transform: (ctx, _) => GetContractInfo(ctx))
                .Where(x => x != null);

            // 2. Generate and Write
            context.RegisterSourceOutput(pipelines, (spc, source) =>
            {
                if (source == null) return;
                try
                {
                    GenerateAndWrite(spc, source, context);
                }
                catch (Exception ex)
                {
                    // Report diagnostic for error
                    var descriptor = new DiagnosticDescriptor(
                       "PRXGEN001",
                       "Error Generating TypeScript",
                       $"Error generating TS for {source.InterfaceName}: {ex.Message} {ex.StackTrace}",
                       "ProximityGenerator",
                       DiagnosticSeverity.Warning,
                       isEnabledByDefault: true);
                    spc.ReportDiagnostic(Diagnostic.Create(descriptor, Location.None));
                }
            });
        }

        private class ContractInfo
        {
            public INamedTypeSymbol InterfaceSymbol;
            public string TargetPath;
            public string InterfaceName;
            public string Namespace;
            public string ProjectDirectory;
        }

        private ContractInfo GetContractInfo(GeneratorAttributeSyntaxContext context)
        {
            var folder = GetProjectDirectory(context.SemanticModel.SyntaxTree);
            var att = context.Attributes.FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == AttributeName);
            if (att == null) return null;

            var targetPath = att.ConstructorArguments[0].Value?.ToString();

            return new ContractInfo
            {
                InterfaceSymbol = (INamedTypeSymbol)context.TargetSymbol,
                TargetPath = targetPath,
                InterfaceName = context.TargetSymbol.Name,
                Namespace = context.TargetSymbol.ContainingNamespace.ToDisplayString(),
                ProjectDirectory = folder
            };
        }

        private string GetProjectDirectory(SyntaxTree tree)
        {
            // Simple heuristic: get directory of the source file
            var path = tree.FilePath;
            if (string.IsNullOrEmpty(path)) return null;
            return Path.GetDirectoryName(path);
        }

        private void GenerateAndWrite(SourceProductionContext spc, ContractInfo info, IncrementalGeneratorInitializationContext globalCtx)
        {
            if (string.IsNullOrEmpty(info.ProjectDirectory)) return;

            var fullPath = Path.Combine(info.ProjectDirectory, info.TargetPath);
            var content = GenerateTypeScript(info.InterfaceSymbol);

            // Writing to disk (Side Effect!)
            // We check if content changed to avoid spamming IO
            if (File.Exists(fullPath))
            {
                var existing = File.ReadAllText(fullPath);
                if (existing == content) return;
            }

            // Determine directory
            var dir = Path.GetDirectoryName(fullPath);
            if (!Directory.Exists(dir)) Directory.CreateDirectory(dir);

            File.WriteAllText(fullPath, content);
        }

        private string GenerateTypeScript(INamedTypeSymbol symbol)
        {
            var sb = new StringBuilder();
            sb.AppendLine("// Auto-generated by SignalR.Proximity.TS.ContractGenerator");
            sb.AppendLine("// Do not edit manually.");
            sb.AppendLine("");

            // 1. Collect Dependent Types (DTOs)
            var typeCollector = new HashSet<INamedTypeSymbol>(SymbolEqualityComparer.Default);
            CollectTypes(symbol, typeCollector);

            // 2. Generate DTOs
            foreach (var type in typeCollector)
            {
                GenerateInterface(sb, type, isContract: false);
            }

            // 3. Generate Contract Interface
            GenerateInterface(sb, symbol, isContract: true);

            // 4. Generate Signatures
            GenerateSignatures(sb, symbol);

            // 5. Generate Path Constant (using fullname lowercased as primitive convention from sample)
            // Sample convention: "sample.signalr.proximity.toaster.ischoolcontract"
            var pathConst = symbol.ToDisplayString().ToLowerInvariant();

            // Extract a variable name part, e1.g. ISchoolContract -> schoolPath
            var varPrefix = symbol.Name.StartsWith("I") ? symbol.Name.Substring(1) : symbol.Name;
            varPrefix = char.ToLower(varPrefix[0]) + varPrefix.Substring(1);

            sb.AppendLine($"export const {varPrefix}Path = \"{pathConst}\";");

            return sb.ToString();
        }

        private void CollectTypes(INamedTypeSymbol symbol, HashSet<INamedTypeSymbol> collector)
        {
            foreach (var member in symbol.GetMembers())
            {
                if (member is IMethodSymbol method)
                {
                    foreach (var arg in method.Parameters)
                    {
                        if (arg.Type is INamedTypeSymbol named && named.SpecialType == SpecialType.None && named.TypeKind == TypeKind.Class)
                        {
                            if (!collector.Contains(named))
                            {
                                collector.Add(named);
                                CollectTypes(named, collector); // Recurse
                            }
                        }
                    }
                }
            }
        }

        private void GenerateInterface(StringBuilder sb, INamedTypeSymbol symbol, bool isContract)
        {
            sb.Append($"export interface {symbol.Name} ");
            sb.AppendLine("{");

            if (isContract)
            {
                foreach (var member in symbol.GetMembers().OfType<IMethodSymbol>())
                {
                    sb.Append($"    {member.Name}(");
                    sb.Append(string.Join(", ", member.Parameters.Select(p => $"{p.Name}: {ToTsType(p.Type)}")));
                    sb.AppendLine("): void;");
                }
            }
            else
            {
                // DTO Mode (Properties)
                foreach (var member in symbol.GetMembers().OfType<IPropertySymbol>())
                {
                    sb.AppendLine($"    {member.Name}: {ToTsType(member.Type)};");
                }
            }

            sb.AppendLine("}");
            sb.AppendLine("");
        }

        private void GenerateSignatures(StringBuilder sb, INamedTypeSymbol symbol)
        {
            var varPrefix = symbol.Name.StartsWith("I") ? symbol.Name.Substring(1) : symbol.Name;
            varPrefix = char.ToLower(varPrefix[0]) + varPrefix.Substring(1);

            sb.AppendLine($"export const {varPrefix}Signatures = {{");
            var methods = symbol.GetMembers().OfType<IMethodSymbol>().ToList();
            for (int i = 0; i < methods.Count; i++)
            {
                var m = methods[i];
                // Gen Signature: "Void ShowInformation(Sample.SignalR.Proximity.Toaster.ToasterRequest)"
                // ReturnType Name(ArgTypes)

                var returnType = m.ReturnsVoid ? "Void" : GetSystemTypeName(m.ReturnType);
                var args = string.Join(", ", m.Parameters.Select(p => GetSystemTypeName(p.Type)));
                var sig = $"{returnType} {m.Name}({args})";

                sb.Append($"    {m.Name}: \"{sig}\"");
                if (i < methods.Count - 1) sb.Append(",");
                sb.AppendLine("");
            }
            sb.AppendLine("};");
            sb.AppendLine("");
        }

        private string GetSystemTypeName(ITypeSymbol type)
        {
            switch (type.SpecialType)
            {
                case SpecialType.System_String: return "System.String";
                case SpecialType.System_Int32: return "System.Int32";
                case SpecialType.System_Double: return "System.Double";
                case SpecialType.System_Boolean: return "System.Boolean";
                case SpecialType.System_Void: return "Void";
            }
            return type.ToDisplayString(); // Fallback for complex types
        }

        private string ToTsType(ITypeSymbol type)
        {
            switch (type.SpecialType)
            {
                case SpecialType.System_String: return "string";
                case SpecialType.System_Int32:
                case SpecialType.System_Double:
                case SpecialType.System_Single:
                case SpecialType.System_Decimal: return "number";
                case SpecialType.System_Boolean: return "boolean";
                case SpecialType.System_DateTime: return "string"; // simplistic
                case SpecialType.System_Void: return "void";
            }
            if (type.TypeKind == TypeKind.Array) return ToTsType(((IArrayTypeSymbol)type).ElementType) + "[]";

            return type.Name; // Hope matches the DTO interface name
        }
    }
}
